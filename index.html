<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3dvr meet â€” starter</title>
  <meta name="description" content="Lightweight WebRTC + Gun.js video chat starter with optional recording." />
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 128 128'%3E%3Crect width='128' height='128' rx='24' fill='%23005cff'/%3E%3Cpath d='M30 64a34 34 0 1 1 68 0 34 34 0 0 1-68 0zm34-22a22 22 0 1 0 0 44 22 22 0 0 0 0-44z' fill='white'/%3E%3C/svg%3E" />
  <style>
    :root{
      --bg:#0b1020; --panel:#121933; --muted:#7b87b9; --text:#e7eefe; --accent:#6aa6ff; --good:#20c997; --warn:#ffcc66; --bad:#ff6b6b;
    }
    *{box-sizing:border-box}
    body{margin:0;font:16px/1.5 system-ui,Segoe UI,Roboto,Inter,Helvetica,Arial;background:linear-gradient(180deg,#0a0f25,#0b1020 35%,#0b0f1a);color:var(--text)}
    header{position:sticky;top:0;z-index:10;background:rgba(11,16,32,.85);backdrop-filter:saturate(1.2) blur(10px);border-bottom:1px solid #18224a}
    .wrap{max-width:1200px;margin:auto;padding:16px}
    h1{margin:0;font-size:20px;letter-spacing:.6px;display:flex;gap:10px;align-items:center}
    .badge{font-size:12px;color:#0b1020;background:var(--accent);padding:2px 8px;border-radius:999px}

    .controls{display:grid;grid-template-columns:repeat(12,1fr);gap:10px;margin-top:12px}
    .controls > *{min-width:0}
    input,select,button{width:100%;padding:10px 12px;border-radius:10px;border:1px solid #233062;background:#0f1630;color:var(--text);outline:none}
    input::placeholder{color:#8992c1}
    button{cursor:pointer;border:1px solid #2b3a78;background:#16214a;transition:.2s}
    button:hover{filter:brightness(1.1)}
    button[aria-pressed="true"],.on{background:#15315f;border-color:#2f5fb7}
    button.good{background:#0f2d25;border-color:#1e8a6d}
    button.warn{background:#3a2a0f;border-color:#b68a2a}
    button.danger{background:#311316;border-color:#9e2d2f}

    .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:12px;padding:16px}
    .tile{position:relative;aspect-ratio:16/9;background:linear-gradient(180deg,#101936,#0b1229);border:1px solid #1a2450;border-radius:14px;overflow:hidden}
    .tile video{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;background:#000}
    .label{position:absolute;left:10px;bottom:10px;padding:4px 8px;border-radius:8px;background:rgba(0,0,0,.5);backdrop-filter:blur(4px);font-size:12px}

    .footer{display:flex;gap:10px;align-items:center;flex-wrap:wrap;padding:16px;border-top:1px solid #18224a}
    .hint{color:var(--muted);font-size:12px}
    .pill{padding:6px 10px;border:1px dashed #2a396f;border-radius:999px}

    @media (max-width:640px){ .controls{grid-template-columns:1fr 1fr} .controls .span-3{grid-column:1/-1}}
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <h1>
        3dvr meet <span class="badge">starter</span>
      </h1>
      <div class="controls">
        <input id="displayName" placeholder="Your name (optional)" />
        <input id="room" placeholder="Room ID (e.g. demo)" />
        <button id="joinBtn" class="good">Join</button>
        <button id="leaveBtn" class="danger" disabled>Leave</button>
        <button id="toggleCam" disabled>Cam</button>
        <button id="toggleMic" disabled>Mic</button>
        <button id="shareScreen" disabled>Share Screen</button>
        <button id="testLink" disabled>Test Link</button>
        <button id="recStart" class="warn" disabled>Start Rec</button>
        <button id="recStop" class="danger" disabled>Stop Rec</button>
        <button id="downloadBtn" disabled>Download</button>
        <div class="pill span-3" id="status">Idle.</div>
      </div>
    </div>
  </header>

  <main class="wrap">
    <section class="grid" id="videos">
      <!-- Video tiles will be injected here -->
    </section>
  </main>

  <footer class="wrap footer">
    <span class="hint">Peer-to-peer via WebRTC. Signaling via Gun.js. Recording is client-side only.</span>
  </footer>

  <!-- Gun.js (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
  <script>
    // --- Utility ---
    const $ = (sel) => document.querySelector(sel);
    const status = (t) => { document.getElementById('status').textContent = t }
    const uuid = () => crypto.randomUUID().slice(0,8);

    // --- Elements ---
    const el = {
      name: $('#displayName'), room: $('#room'),
      join: $('#joinBtn'), leave: $('#leaveBtn'),
      cam: $('#toggleCam'), mic: $('#toggleMic'),
      screen: $('#shareScreen'),
      recStart: $('#recStart'), recStop: $('#recStop'), dl: $('#downloadBtn'),
      test: $('#testLink'),
      videos: $('#videos')
    };

    // --- State ---
    const me = { id: uuid(), name: '', room: null, joined:false };
    const peers = new Map(); // id -> {pc?, stream?, videos?, meta?, dialing?, pendingIce?, dc?}
    const testState = { value:false, actor:null };
    const pendingAcks = new Map();

    function ensurePeerRecord(id){
      let record = peers.get(id);
      if(!record){
        record = {};
        peers.set(id, record);
      }
      return record;
    }

    function updatePeerTileLabel(id){
      const record = peers.get(id);
      if(record?.videos){
        record.videos.label.textContent = (record.meta?.name) || id;
      }
    }

    function updateTestButton(){
      const label = testState.value ? `Link test ON${testState.actor ? ` (${testState.actor})` : ''}` : 'Test Link';
      el.test.textContent = label;
      el.test.classList.toggle('on', !!testState.value);
      el.test.setAttribute('aria-pressed', String(!!testState.value));
    }

    function setTestState(value, actor){
      testState.value = value;
      testState.actor = actor || null;
      updateTestButton();
    }

    function broadcastData(payload){
      const message = JSON.stringify(payload);
      for(const [, entry] of peers){
        const dc = entry.dc;
        if(dc && dc.readyState === 'open'){
          try { dc.send(message); } catch(err){ console.warn('Data send failed', err); }
        }
      }
    }

    function handleDataMessage(peerId, raw){
      let msg;
      try {
        msg = JSON.parse(raw);
      } catch(err){
        console.warn('Invalid data message', err);
        return;
      }
      if(msg.type === 'test-toggle'){
        const actor = msg.name || peers.get(peerId)?.meta?.name || peerId;
        setTestState(!!msg.value, actor);
        status(`Test toggled ${msg.value ? 'on' : 'off'} by ${actor}`);
        const record = peers.get(peerId);
        if(record?.dc && record.dc.readyState === 'open' && msg.id){
          record.dc.send(JSON.stringify({
            type: 'test-ack', id: msg.id, value: !!msg.value,
            from: me.id, name: me.name
          }));
        }
      } else if(msg.type === 'test-ack'){
        if(msg.id && pendingAcks.has(msg.id)){
          const timer = pendingAcks.get(msg.id);
          clearTimeout(timer);
          pendingAcks.delete(msg.id);
          const actor = msg.name || peers.get(peerId)?.meta?.name || peerId;
          status(`Ack from ${actor}`);
        }
      } else if(msg.type === 'test-sync'){
        const actor = msg.name || peers.get(peerId)?.meta?.name || peerId;
        setTestState(!!msg.value, actor);
      }
    }

    function setupDataChannel(peerId, channel){
      const record = ensurePeerRecord(peerId);
      record.dc = channel;
      channel.onmessage = (event)=> handleDataMessage(peerId, event.data);
      channel.onopen = ()=>{
        status(`Data channel open with ${record.meta?.name || peerId}`);
        try {
          channel.send(JSON.stringify({
            type: 'test-sync', value: testState.value,
            from: me.id, name: me.name
          }));
        } catch(err){ console.warn('Sync send failed', err); }
      };
      channel.onclose = ()=>{
        if(record.dc === channel){ delete record.dc; }
      };
      channel.onerror = (err)=> console.warn('Data channel error', err);
    }
    let localStream = null;
    let screenStream = null;

    // Recording state
    let mixerCanvas, mixerCtx, mixRAF;
    let audioCtx, mixDest, mediaRecorder, chunks = [];

    // --- Gun setup (signaling only) ---
    const gun = Gun({ peers: [
      'https://3dvr-relay.fly.dev/gun'
    ] });

    function roomNode(room){ return gun.get('3dvr-meet').get(room); }

    // --- UI helpers ---
    function addVideoTile(id, label){
      const tile = document.createElement('div'); tile.className='tile'; tile.id = `tile-${id}`;
      const v = document.createElement('video'); v.autoplay = true; v.playsInline = true; v.muted = (id==='me');
      const tag = document.createElement('div'); tag.className='label'; tag.textContent = label || id;
      tile.appendChild(v); tile.appendChild(tag);
      el.videos.appendChild(tile);
      return { tile, v, label: tag };
    }
    function removeVideoTile(id){ const t = document.getElementById(`tile-${id}`); if(t) t.remove(); }

    // --- Media setup ---
    async function getUserMediaIfNeeded(){
      if(localStream) return localStream;
      localStream = await navigator.mediaDevices.getUserMedia({video:true,audio:true});
      const meTile = addVideoTile('me', me.name || 'Me');
      meTile.v.srcObject = localStream;
      peers.set('me', { stream: localStream, videos: meTile });
      el.cam.disabled = el.mic.disabled = el.screen.disabled = false;
      el.recStart.disabled = false;
      return localStream;
    }

    // --- WebRTC core ---
    const rtcConfig = { iceServers: [
      { urls: 'stun:stun.l.google.com:19302' }
    ]};

    async function createPeerConnection(peerId){
      const pc = new RTCPeerConnection(rtcConfig);
      const record = ensurePeerRecord(peerId);
      record.pc = pc;

      // Add our current tracks
      (localStream?.getTracks() || []).forEach(t => pc.addTrack(t, localStream));
      (screenStream?.getTracks() || []).forEach(t => pc.addTrack(t, screenStream));

      // Remote tracks
      const remoteId = peerId;
      pc.ontrack = (e)=>{
        const entry = ensurePeerRecord(remoteId);
        entry.pc = pc;
        if(!entry.stream){ entry.stream = new MediaStream(); }
        const inbound = e.streams?.[0];
        if(inbound){
          inbound.getTracks().forEach(tr=>{
            if(!entry.stream.getTrackById(tr.id)) entry.stream.addTrack(tr);
          });
        } else if(e.track && !entry.stream.getTrackById(e.track.id)){
          entry.stream.addTrack(e.track);
        }
        if(!entry.videos){
          entry.videos = addVideoTile(remoteId, entry.meta?.name || remoteId);
        }
        entry.videos.v.srcObject = entry.stream;
        updatePeerTileLabel(remoteId);
      };

      pc.onicecandidate = (e)=>{
        if(e.candidate){
          roomNode(me.room).get('signals').get(remoteId).set({
            from: me.id, type: 'ice', candidate: e.candidate
          });
        }
      };
      pc.ondatachannel = (event)=>{
        setupDataChannel(remoteId, event.channel);
      };
      pc.onconnectionstatechange = ()=>{
        status(`Peer ${remoteId}: ${pc.connectionState}`);
        if(['failed','disconnected','closed'].includes(pc.connectionState)){
          const entry = peers.get(remoteId);
          if(entry?.stream){ entry.stream.getTracks().forEach(t=>t.stop()); }
          if(entry?.dc && entry.dc.readyState !== 'closed'){ try { entry.dc.close(); } catch{} }
          removeVideoTile(remoteId);
          peers.delete(remoteId);
        }
      }
      if(me.id < peerId && !record.dc){
        const channel = pc.createDataChannel('control', { ordered: true });
        setupDataChannel(peerId, channel);
      }
      return pc;
    }

    // --- Signaling (Gun.js) ---
    function startSignaling(){
      const room = roomNode(me.room);

      // Listen for new members
      room.get('members').map().on((val, id)=>{
        if(id===me.id) return;
        if(!val){
          const existing = peers.get(id);
          if(existing?.stream){ existing.stream.getTracks().forEach(t=>t.stop()); }
          if(existing?.dc && existing.dc.readyState !== 'closed'){ try { existing.dc.close(); } catch{} }
          if(existing?.videos) removeVideoTile(id);
          peers.delete(id);
          return;
        }
        const entry = ensurePeerRecord(id);
        entry.meta = val;
        updatePeerTileLabel(id);
        if(!me.joined) return;
        // Initiate connection if we see someone and we have a lower id (simple deterministic rule)
        if(me.id < id && !entry.pc && !entry.dialing){
          entry.dialing = true;
          dial(id).catch(err=>{
            console.error(err);
            entry.dialing = false;
          });
        }
      });

      // Listen for signals directed to me
      room.get('signals').get(me.id).map().on(async (sig)=>{
        if(!sig) return;
        const { from, type } = sig;
        if(from === me.id) return;
        const entry = ensurePeerRecord(from);
        if(type==='offer'){
          if(!entry.pc){
            await createPeerConnection(from);
          }
          await entry.pc.setRemoteDescription(new RTCSessionDescription(sig.sdp));
          const answer = await entry.pc.createAnswer();
          await entry.pc.setLocalDescription(answer);
          room.get('signals').get(from).set({ from: me.id, type:'answer', sdp: entry.pc.localDescription });
          if(entry.pendingIce?.length){
            for(const candidate of entry.pendingIce){
              try{ await entry.pc.addIceCandidate(candidate); }catch(e){ console.warn(e); }
            }
            entry.pendingIce = [];
          }
        } else if(type==='answer'){
          if(entry.pc){
            await entry.pc.setRemoteDescription(new RTCSessionDescription(sig.sdp));
            if(entry.pendingIce?.length){
              for(const candidate of entry.pendingIce){
                try{ await entry.pc.addIceCandidate(candidate); }catch(e){ console.warn(e); }
              }
              entry.pendingIce = [];
            }
          }
        } else if(type==='ice'){
          if(sig.candidate){
            if(entry.pc){
              try{ await entry.pc.addIceCandidate(sig.candidate); }catch(e){ console.warn(e); }
            } else {
              entry.pendingIce = entry.pendingIce || [];
              entry.pendingIce.push(sig.candidate);
            }
          }
        }
      });
    }

    async function dial(peerId){
      const entry = ensurePeerRecord(peerId);
      try{
        const pc = await createPeerConnection(peerId);
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        roomNode(me.room).get('signals').get(peerId).set({ from: me.id, type:'offer', sdp: offer });
      } finally {
        entry.dialing = false;
      }
    }

    // --- Join / Leave ---
    async function join(){
      if(me.joined){ status(`Already in room: ${me.room}`); return; }
      const room = (el.room.value || location.hash.slice(1) || 'demo').trim();
      me.room = room; me.name = el.name.value.trim() || `guest-${me.id}`;
      await getUserMediaIfNeeded();
      me.joined = true;
      startSignaling();
      // Advertise ourselves
      roomNode(room).get('members').get(me.id).put({ name: me.name, at: Date.now() });
      status(`Joined room: ${room} as ${me.name}`);
      el.join.disabled = true; el.leave.disabled = false;
      el.test.disabled = false;
      updateTestButton();
      history.replaceState(null, '', `#${encodeURIComponent(room)}`);
    }

    async function leave(){
      me.joined = false;
      // Close PCs
      for(const [id, p] of [...peers]){
        if(p.pc) try{ p.pc.close(); }catch{}
        if(id!=='me') removeVideoTile(id);
        peers.delete(id);
      }
      // Stop screen
      if(screenStream){ screenStream.getTracks().forEach(t=>t.stop()); screenStream=null; }
      // Remove from room
      if(me.room) roomNode(me.room).get('members').get(me.id).put(null);
      el.join.disabled = false; el.leave.disabled = true;
      el.test.disabled = true;
      for(const [,timer] of pendingAcks){ clearTimeout(timer); }
      pendingAcks.clear();
      setTestState(false, null);
      status('Left room.');
    }

    // --- Controls ---
    el.join.onclick = join;
    el.leave.onclick = leave;

    el.cam.onclick = ()=>{
      if(!localStream) return;
      const v = localStream.getVideoTracks()[0]; if(!v) return;
      v.enabled = !v.enabled; el.cam.setAttribute('aria-pressed', String(!v.enabled));
    };
    el.mic.onclick = ()=>{
      if(!localStream) return;
      const a = localStream.getAudioTracks()[0]; if(!a) return;
      a.enabled = !a.enabled; el.mic.setAttribute('aria-pressed', String(!a.enabled));
    };
    el.screen.onclick = async ()=>{
      try{
        if(!screenStream){
          screenStream = await navigator.mediaDevices.getDisplayMedia({video:true,audio:true});
          // Show our own screen as a tile
          const id = 'screen';
          const tile = addVideoTile(id, 'My Screen');
          tile.v.srcObject = screenStream;
          peers.set(id, { stream: screenStream, videos: tile });
          // Add to all PCs
          for(const [,p] of peers){ if(p.pc){ screenStream.getTracks().forEach(t=>p.pc.addTrack(t, screenStream)); } }
          screenStream.getVideoTracks()[0].addEventListener('ended', ()=>{ // cleanup on stop
            removeVideoTile('screen'); peers.delete('screen');
            for(const [,p] of peers){ if(p.pc){ p.pc.getSenders().forEach(s=>{ if(s.track && s.track.kind==='video' && s.track.label.includes('Screen')) s.replaceTrack(null); }); } }
            screenStream=null; status('Screen share stopped.');
          });
        } else {
          screenStream.getTracks().forEach(t=>t.stop()); screenStream=null; removeVideoTile('screen');
      }
    }catch(e){ console.error(e); status('Screen share blocked.'); }
    };

    el.test.onclick = ()=>{
      if(el.test.disabled) return;
      const next = !testState.value;
      setTestState(next, 'You');
      const id = uuid();
      const timer = setTimeout(()=>{
        if(pendingAcks.has(id)){
          pendingAcks.delete(id);
          status('No acknowledgement yet.');
        }
      }, 5000);
      pendingAcks.set(id, timer);
      broadcastData({ type: 'test-toggle', value: next, id, from: me.id, name: me.name });
      status(`Sent test ${next ? 'on' : 'off'} toggleâ€¦`);
    };

    // --- Recording (client-side) ---
    function buildMixer(){
      mixerCanvas = document.createElement('canvas');
      mixerCanvas.width = 1920; mixerCanvas.height = 1080;
      mixerCtx = mixerCanvas.getContext('2d');

      // Audio mix
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      mixDest = audioCtx.createMediaStreamDestination();

      // For each available MediaStream with audio, connect to mix
      function connectAudioFrom(stream){
        try {
          const src = audioCtx.createMediaStreamSource(stream);
          const gain = audioCtx.createGain(); gain.gain.value = 1.0; // simple unity gain
          src.connect(gain).connect(mixDest);
        } catch(err){ /* streams without audio will throw */ }
      }

      // Connect current streams
      for(const [id,p] of peers){ if(p?.stream) connectAudioFrom(p.stream); }

      // Observe future streams
      const observer = new MutationObserver(()=>{
        // reconnect on layout changes (naive approach)
      });
      observer.observe(el.videos,{childList:true});

      const draw = ()=>{
        const tiles = [...el.videos.querySelectorAll('video')];
        const n = Math.max(1, tiles.length);
        mixerCtx.fillStyle = '#000'; mixerCtx.fillRect(0,0,mixerCanvas.width,mixerCanvas.height);
        const cols = Math.ceil(Math.sqrt(n));
        const rows = Math.ceil(n/cols);
        const w = mixerCanvas.width / cols, h = mixerCanvas.height / rows;
        tiles.forEach((vid,i)=>{
          const x = (i%cols)*w, y = Math.floor(i/cols)*h;
          try { mixerCtx.drawImage(vid, x, y, w, h); } catch{}
        });
        mixRAF = requestAnimationFrame(draw);
      };
      draw();

      const videoStream = mixerCanvas.captureStream(30);
      const mixed = new MediaStream([
        ...videoStream.getVideoTracks(),
        ...mixDest.stream.getAudioTracks()
      ]);
      return mixed;
    }

    let lastBlob=null;
    el.recStart.onclick = ()=>{
      const stream = buildMixer();
      chunks = [];
      const opts = { mimeType: 'video/webm;codecs=vp9,opus' };
      try{ mediaRecorder = new MediaRecorder(stream, opts); }
      catch(e){ mediaRecorder = new MediaRecorder(stream); }
      mediaRecorder.ondataavailable = (e)=>{ if(e.data.size) chunks.push(e.data); };
      mediaRecorder.onstop = ()=>{
        cancelAnimationFrame(mixRAF);
        lastBlob = new Blob(chunks, {type:'video/webm'});
        el.dl.disabled = false; status(`Recording ready: ${(lastBlob.size/1e6).toFixed(1)} MB`);
      };
      mediaRecorder.start(1000);
      el.recStart.disabled = true; el.recStop.disabled = false; status('Recordingâ€¦');
    };
    el.recStop.onclick = ()=>{ if(mediaRecorder && mediaRecorder.state!=='inactive') mediaRecorder.stop(); el.recStop.disabled = true; el.recStart.disabled = false; };
    el.dl.onclick = ()=>{
      if(!lastBlob) return; const url = URL.createObjectURL(lastBlob);
      const a = document.createElement('a'); a.href=url; a.download=`3dvr-meet-${Date.now()}.webm`; a.click();
      setTimeout(()=>URL.revokeObjectURL(url), 30000);
    }

    updateTestButton();

    // Auto-fill room from hash
    window.addEventListener('DOMContentLoaded',()=>{
      const r = location.hash.slice(1); if(r) el.room.value = decodeURIComponent(r);
    });
  </script>
</body>
</html>
