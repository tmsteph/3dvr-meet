<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3dvr meet — starter</title>
  <meta name="description" content="Lightweight WebRTC + Gun.js video chat starter with optional recording." />
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 128 128'%3E%3Crect width='128' height='128' rx='24' fill='%23005cff'/%3E%3Cpath d='M30 64a34 34 0 1 1 68 0 34 34 0 0 1-68 0zm34-22a22 22 0 1 0 0 44 22 22 0 0 0 0-44z' fill='white'/%3E%3C/svg%3E" />
  <style>
    :root{
      --bg:#0b1020; --panel:#121933; --muted:#7b87b9; --text:#e7eefe; --accent:#6aa6ff; --good:#20c997; --warn:#ffcc66; --bad:#ff6b6b;
    }
    *{box-sizing:border-box}
    body{margin:0;font:16px/1.5 system-ui,Segoe UI,Roboto,Inter,Helvetica,Arial;background:linear-gradient(180deg,#0a0f25,#0b1020 35%,#0b0f1a);color:var(--text)}
    header{position:sticky;top:0;z-index:10;background:rgba(11,16,32,.85);backdrop-filter:saturate(1.2) blur(10px);border-bottom:1px solid #18224a}
    .wrap{max-width:1200px;margin:auto;padding:16px}
    h1{margin:0;font-size:20px;letter-spacing:.6px;display:flex;gap:10px;align-items:center}
    .badge{font-size:12px;color:#0b1020;background:var(--accent);padding:2px 8px;border-radius:999px}

    .controls{display:grid;grid-template-columns:repeat(12,1fr);gap:10px;margin-top:12px}
    .controls > *{min-width:0}
    input,select,button{width:100%;padding:10px 12px;border-radius:10px;border:1px solid #233062;background:#0f1630;color:var(--text);outline:none}
    input::placeholder{color:#8992c1}
    button{cursor:pointer;border:1px solid #2b3a78;background:#16214a;transition:.2s}
    button:hover{filter:brightness(1.1)}
    button[aria-pressed="true"],.on{background:#15315f;border-color:#2f5fb7}
    button.good{background:#0f2d25;border-color:#1e8a6d}
    button.warn{background:#3a2a0f;border-color:#b68a2a}
    button.danger{background:#311316;border-color:#9e2d2f}

    .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:12px;padding:16px}
    .tile{position:relative;aspect-ratio:16/9;background:linear-gradient(180deg,#101936,#0b1229);border:1px solid #1a2450;border-radius:14px;overflow:hidden}
    .tile video{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;background:#000}
    .label{position:absolute;left:10px;bottom:10px;padding:4px 8px;border-radius:8px;background:rgba(0,0,0,.5);backdrop-filter:blur(4px);font-size:12px}

    .footer{display:flex;gap:10px;align-items:center;flex-wrap:wrap;padding:16px;border-top:1px solid #18224a}
    .hint{color:var(--muted);font-size:12px}
    .pill{padding:6px 10px;border:1px dashed #2a396f;border-radius:999px}

    @media (max-width:640px){ .controls{grid-template-columns:1fr 1fr} .controls .span-3{grid-column:1/-1}}
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <h1>
        3dvr meet <span class="badge">starter</span>
      </h1>
      <div class="controls">
        <input id="displayName" placeholder="Your name (optional)" />
        <input id="room" placeholder="Room ID (e.g. demo)" />
        <input id="relays" class="span-3" placeholder="Relays (comma separated URLs)" />
        <button id="joinBtn" class="good">Join</button>
        <button id="leaveBtn" class="danger" disabled>Leave</button>
        <button id="toggleCam" disabled>Cam</button>
        <button id="toggleMic" disabled>Mic</button>
        <button id="shareScreen" disabled>Share Screen</button>
        <button id="testLink" disabled>Test Link</button>
        <button id="recStart" class="warn" disabled>Start Rec</button>
        <button id="recStop" class="danger" disabled>Stop Rec</button>
        <button id="downloadBtn" disabled>Download</button>
        <div class="pill span-3" id="status">Idle.</div>
      </div>
    </div>
  </header>

  <main class="wrap">
    <section class="grid" id="videos">
      <!-- Video tiles will be injected here -->
    </section>
  </main>

  <footer class="wrap footer">
    <span class="hint">Peer-to-peer via WebRTC. Signaling via Gun.js. Recording is client-side only.</span>
  </footer>

  <!-- Gun.js (local copy) -->
  <script src="vendor/gun.js"></script>
  <script>
    // --- Utility ---
    const $ = (sel) => document.querySelector(sel);
    const statusEl = document.getElementById('status');
    const statusState = { primary: 'Idle.', relay: '' };

    function renderStatus(){
      const parts = [];
      if(statusState.primary){ parts.push(statusState.primary); }
      if(statusState.relay){ parts.push(statusState.relay); }
      statusEl.textContent = parts.join(' — ') || '';
    }

    function status(message){
      statusState.primary = message || '';
      renderStatus();
    }

    function setRelayStatus(message){
      const next = message || '';
      if(statusState.relay === next) return;
      statusState.relay = next;
      renderStatus();
    }

    renderStatus();

    const RELAY_STORAGE_KEY = '3dvr.relays';

    function normalizeRelayUrl(value){
      if(!value) return null;
      let text = String(value).trim();
      if(!text) return null;
      try {
        if(!/^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(text)){
          const scheme = location.protocol === 'https:' ? 'https://' : 'http://';
          text = scheme + text.replace(/^\/+/, '');
        }
        const url = new URL(text, location.origin);
        if(!url.pathname.endsWith('/gun')){
          url.pathname = url.pathname.replace(/\/+$/, '') + '/gun';
        }
        if(url.protocol === 'http:' && location.protocol === 'https:'){
          url.protocol = 'https:';
        }
        if(url.protocol === 'ws:' && location.protocol === 'https:'){
          url.protocol = 'wss:';
        }
        url.hash = '';
        url.search = '';
        return url.toString();
      } catch(err){
        console.warn('Invalid relay url', value, err);
        return null;
      }
    }

    function uniqueList(list){
      const seen = new Set();
      const out = [];
      for(const item of list){
        if(!item || seen.has(item)) continue;
        seen.add(item);
        out.push(item);
      }
      return out;
    }

    function listsEqual(a, b){
      if(a === b) return true;
      if(!Array.isArray(a) || !Array.isArray(b)) return false;
      if(a.length !== b.length) return false;
      for(let i=0;i<a.length;i++){
        if(a[i] !== b[i]) return false;
      }
      return true;
    }

    function loadStoredRelays(){
      try {
        const raw = localStorage.getItem(RELAY_STORAGE_KEY);
        if(!raw) return [];
        const parsed = JSON.parse(raw);
        if(Array.isArray(parsed)){
          return uniqueList(parsed.map(normalizeRelayUrl).filter(Boolean));
        }
      } catch(err){
        console.warn('Failed to load relay preferences', err);
      }
      return [];
    }

    function persistRelays(list){
      try {
        if(list?.length){
          localStorage.setItem(RELAY_STORAGE_KEY, JSON.stringify(list));
        } else {
          localStorage.removeItem(RELAY_STORAGE_KEY);
        }
      } catch(err){
        console.warn('Unable to persist relay preferences', err);
      }
    }

    function parseRelayInput(str){
      if(!str) return [];
      return uniqueList(str.split(/[\s,]+/).map(normalizeRelayUrl).filter(Boolean));
    }

    function computeLocalRelay(){
      if(location.protocol === 'https:') return null;
      const host = location.hostname || '';
      if(host === 'localhost' || host.startsWith('127.') || host === '0.0.0.0'){
        return `http://${host}:8765/gun`;
      }
      return null;
    }

    const DEFAULT_GUN_RELAYS = [
      'https://3dvr-relay.fly.dev/gun'
    ];

    const normalizedDefaultRelays = uniqueList(DEFAULT_GUN_RELAYS.map(normalizeRelayUrl).filter(Boolean));
    const localRelayUrl = computeLocalRelay();
    let customRelayList = loadStoredRelays();

    function computeActivePeers(customList){
      const base = (customList && customList.length) ? customList : normalizedDefaultRelays;
      const all = [];
      if(localRelayUrl) all.push(localRelayUrl);
      all.push(...base);
      return uniqueList(all);
    }

    let activeGunPeers = computeActivePeers(customRelayList);

    const uuid = () => crypto.randomUUID().slice(0,8);

    // --- Elements ---
    const el = {
      name: $('#displayName'), room: $('#room'), relays: $('#relays'),
      join: $('#joinBtn'), leave: $('#leaveBtn'),
      cam: $('#toggleCam'), mic: $('#toggleMic'),
      screen: $('#shareScreen'),
      recStart: $('#recStart'), recStop: $('#recStop'), dl: $('#downloadBtn'),
      test: $('#testLink'),
      videos: $('#videos')
    };

    function setCustomRelays(list, { announce = true } = {}){
      const normalized = uniqueList((list || []).map(normalizeRelayUrl).filter(Boolean));
      if(listsEqual(normalized, customRelayList)){
        return normalized;
      }
      customRelayList = normalized;
      persistRelays(normalized);
      applyActivePeers(computeActivePeers(normalized));
      if(announce){
        if(normalized.length){
          const plural = normalized.length === 1 ? '' : 's';
          status(`Using ${normalized.length} custom relay${plural}.`);
        } else {
          status('Cleared custom relay preferences. Using default relay.');
        }
      }
      return normalized;
    }

    if(el.relays){
      if(customRelayList.length){
        el.relays.value = customRelayList.join(', ');
      } else if(normalizedDefaultRelays.length){
        el.relays.placeholder = normalizedDefaultRelays.join(', ');
      }
      const relayInputHandler = ()=>{
        setCustomRelays(parseRelayInput(el.relays.value));
      };
      el.relays.addEventListener('change', relayInputHandler);
      el.relays.addEventListener('blur', relayInputHandler);
    }

    // --- State ---
    const me = { id: uuid(), name: '', room: null, joined:false };
    const peers = new Map(); // id -> {pc?, stream?, videos?, meta?, dialing?, pendingIce?}
    const testState = { count: 0, actorName: null, actorId: null };
    const testClicks = new Map(); // peerId -> { count, name, by, at }
    let testWatcher = null;
    let testInitTimer = null;
    let testInitializing = false;

    function ensurePeerRecord(id){
      let record = peers.get(id);
      if(!record){
        record = {};
        peers.set(id, record);
      }
      return record;
    }

    function updatePeerTileLabel(id){
      const record = peers.get(id);
      if(record?.videos){
        record.videos.label.textContent = (record.meta?.name) || id;
      }
    }

    function updateTestButton(){
      const hasCount = testState.count > 0;
      const base = hasCount ? `Test Clicks: ${testState.count}` : 'Test Link';
      let suffix = '';
      if(hasCount && testState.actorName){
        const actorLabel = testState.actorId === me.id ? 'You' : testState.actorName;
        suffix = ` (last: ${actorLabel})`;
      }
      el.test.textContent = base + suffix;
      el.test.classList.toggle('on', hasCount);
      el.test.setAttribute('aria-pressed', hasCount ? 'true' : 'false');
    }

    function setTestState(count, actorName, actorId){
      const nextCount = (typeof count === 'number' && Number.isFinite(count)) ? count : Number(count) || 0;
      testState.count = Math.max(0, Math.floor(nextCount));
      testState.actorName = actorName || null;
      testState.actorId = actorId || null;
      updateTestButton();
    }

    function recomputeTestState(){
      const entries = [...testClicks.values()].filter(Boolean);
      if(!entries.length){
        setTestState(0, null, null);
        return;
      }
      let total = 0;
      let latest = null;
      for(const item of entries){
        const amount = (typeof item.count === 'number' && Number.isFinite(item.count)) ? item.count : Number(item.count) || 0;
        total += Math.max(0, Math.floor(amount));
        const when = (typeof item.at === 'number' && Number.isFinite(item.at)) ? item.at : Number(item.at) || 0;
        if(!latest || when >= latest.when){
          latest = {
            when,
            name: (item.name && String(item.name).trim()) || item.by || null,
            id: item.by || null
          };
        }
      }
      setTestState(total, latest?.name || null, latest?.id || null);
    }

    function subscribeTestClicks(roomId){
      if(testWatcher && typeof testWatcher.off === 'function'){ testWatcher.off(); }
      testWatcher = null;
      if(testInitTimer){ clearTimeout(testInitTimer); testInitTimer = null; }
      testInitializing = true;
      testInitTimer = setTimeout(()=>{
        testInitializing = false;
        testInitTimer = null;
        if(testState.count > 0){
          const via = testState.actorId === me.id ? 'You' : (testState.actorName || 'another participant');
          status(`Synced test clicks to #${testState.count} via ${via}`);
        }
      }, 400);
      testClicks.clear();
      recomputeTestState();

      const chain = roomNode(roomId).get('testClicks').map();
      chain.on((val, key)=>{
        if(key === '_' || key == null) return;
        const known = testClicks.has(key);
        if(!val){
          if(known){
            testClicks.delete(key);
            recomputeTestState();
          }
          return;
        }
        if(typeof val === 'object'){
          const prevTotal = testState.count;
          testClicks.set(key, val);
          recomputeTestState();
          if(!testInitializing && key !== me.id && testState.count > prevTotal){
            const actorName = (val.name && String(val.name).trim()) || val.by || key;
            status(`Received test click #${testState.count} from ${actorName}`);
          }
        }
      });
      testWatcher = chain;
    }

    let localStream = null;
    let screenStream = null;

    // Recording state
    let mixerCanvas, mixerCtx, mixRAF;
    let audioCtx, mixDest, mediaRecorder, chunks = [];

    // --- Gun setup (signaling only) ---
    const gun = Gun({
      peers: activeGunPeers,
      localStorage: false,
      radisk: false,
      retry: 2000
    });

    const connectedRelays = new Map();
    let sawRelayConnection = false;

    function relayHost(url){
      try { return new URL(url).host; }
      catch { return url; }
    }

    function describeRelayStatus(){
      if(connectedRelays.size){
        sawRelayConnection = true;
        const hosts = [...connectedRelays.values()];
        const listed = hosts.slice(0, 2).join(', ');
        const suffix = hosts.length > 2 ? '…' : '';
        const label = hosts.length === 1 ? 'relay' : 'relays';
        setRelayStatus(`Connected to signaling ${label}: ${listed}${suffix}`);
      } else {
        const targetLabel = activeGunPeers.length === 1 ? 'relay' : 'relays';
        const msg = sawRelayConnection ? `Reconnecting to signaling ${targetLabel}…` : `Connecting to signaling ${targetLabel}…`;
        setRelayStatus(msg);
      }
    }

    describeRelayStatus();

    function applyActivePeers(peers){
      activeGunPeers = uniqueList(peers);
      const peerMap = {};
      for(const url of activeGunPeers){
        peerMap[url] = { url };
      }
      gun.opt({ peers: peerMap });
      for(const url of [...connectedRelays.keys()]){
        if(!peerMap[url]) connectedRelays.delete(url);
      }
      describeRelayStatus();
    }

    gun.on('hi', (peer)=>{
      if(peer?.url){
        connectedRelays.set(peer.url, relayHost(peer.url));
        describeRelayStatus();
      }
    });

    gun.on('bye', (peer)=>{
      if(peer?.url){
        connectedRelays.delete(peer.url);
        describeRelayStatus();
      }
    });

    function roomNode(room){ return gun.get('3dvr-meet').get(room); }

    // --- UI helpers ---
    function addVideoTile(id, label){
      const tile = document.createElement('div'); tile.className='tile'; tile.id = `tile-${id}`;
      const v = document.createElement('video'); v.autoplay = true; v.playsInline = true; v.muted = (id==='me');
      const tag = document.createElement('div'); tag.className='label'; tag.textContent = label || id;
      tile.appendChild(v); tile.appendChild(tag);
      el.videos.appendChild(tile);
      return { tile, v, label: tag };
    }
    function removeVideoTile(id){ const t = document.getElementById(`tile-${id}`); if(t) t.remove(); }

    // --- Media setup ---
    async function getUserMediaIfNeeded(){
      if(localStream) return localStream;
      localStream = await navigator.mediaDevices.getUserMedia({video:true,audio:true});
      const meTile = addVideoTile('me', me.name || 'Me');
      meTile.v.srcObject = localStream;
      peers.set('me', { stream: localStream, videos: meTile });
      el.cam.disabled = el.mic.disabled = el.screen.disabled = false;
      el.recStart.disabled = false;
      return localStream;
    }

    // --- WebRTC core ---
    const rtcConfig = { iceServers: [
      { urls: 'stun:stun.l.google.com:19302' }
    ]};

    async function createPeerConnection(peerId){
      const pc = new RTCPeerConnection(rtcConfig);
      const record = ensurePeerRecord(peerId);
      record.pc = pc;

      // Add our current tracks
      (localStream?.getTracks() || []).forEach(t => pc.addTrack(t, localStream));
      (screenStream?.getTracks() || []).forEach(t => pc.addTrack(t, screenStream));

      // Remote tracks
      const remoteId = peerId;
      pc.ontrack = (e)=>{
        const entry = ensurePeerRecord(remoteId);
        entry.pc = pc;
        if(!entry.stream){ entry.stream = new MediaStream(); }
        const inbound = e.streams?.[0];
        if(inbound){
          inbound.getTracks().forEach(tr=>{
            if(!entry.stream.getTrackById(tr.id)) entry.stream.addTrack(tr);
          });
        } else if(e.track && !entry.stream.getTrackById(e.track.id)){
          entry.stream.addTrack(e.track);
        }
        if(!entry.videos){
          entry.videos = addVideoTile(remoteId, entry.meta?.name || remoteId);
        }
        entry.videos.v.srcObject = entry.stream;
        updatePeerTileLabel(remoteId);
      };

      pc.onicecandidate = (e)=>{
        if(e.candidate){
          const payload = (typeof e.candidate.toJSON === 'function') ? e.candidate.toJSON() : e.candidate;
          roomNode(me.room).get('signals').get(remoteId).set({
            from: me.id, type: 'ice', candidate: payload
          });
        }
      };
      pc.onconnectionstatechange = ()=>{
        status(`Peer ${remoteId}: ${pc.connectionState}`);
        if(['failed','disconnected','closed'].includes(pc.connectionState)){
          const entry = peers.get(remoteId);
          if(entry?.stream){ entry.stream.getTracks().forEach(t=>t.stop()); }
          removeVideoTile(remoteId);
          peers.delete(remoteId);
        }
      }
      return pc;
    }

    // --- Signaling (Gun.js) ---
    function startSignaling(){
      const room = roomNode(me.room);

      // Listen for new members
      room.get('members').map().on((val, id)=>{
        if(id===me.id) return;
        if(!val){
          const existing = peers.get(id);
          if(existing?.stream){ existing.stream.getTracks().forEach(t=>t.stop()); }
          if(existing?.videos) removeVideoTile(id);
          peers.delete(id);
          return;
        }
        const entry = ensurePeerRecord(id);
        entry.meta = val;
        updatePeerTileLabel(id);
        if(!me.joined) return;
        // Initiate connection if we see someone and we have a lower id (simple deterministic rule)
        if(me.id < id && !entry.pc && !entry.dialing){
          entry.dialing = true;
          dial(id).catch(err=>{
            console.error(err);
            entry.dialing = false;
          });
        }
      });

      // Listen for signals directed to me
      room.get('signals').get(me.id).map().on(async (sig)=>{
        if(!sig) return;
        const { from, type } = sig;
        if(from === me.id) return;
        const entry = ensurePeerRecord(from);
        if(type==='offer'){
          if(!entry.pc){
            await createPeerConnection(from);
          }
          await entry.pc.setRemoteDescription(new RTCSessionDescription(sig.sdp));
          const answer = await entry.pc.createAnswer();
          await entry.pc.setLocalDescription(answer);
          room.get('signals').get(from).set({ from: me.id, type:'answer', sdp: entry.pc.localDescription });
          if(entry.pendingIce?.length){
            for(const candidate of entry.pendingIce){
              try{ await entry.pc.addIceCandidate(candidate); }catch(e){ console.warn(e); }
            }
            entry.pendingIce = [];
          }
        } else if(type==='answer'){
          if(entry.pc){
            await entry.pc.setRemoteDescription(new RTCSessionDescription(sig.sdp));
            if(entry.pendingIce?.length){
              for(const candidate of entry.pendingIce){
                try{ await entry.pc.addIceCandidate(candidate); }catch(e){ console.warn(e); }
              }
              entry.pendingIce = [];
            }
          }
        } else if(type==='ice'){
          if(sig.candidate){
            if(entry.pc){
              try{ await entry.pc.addIceCandidate(sig.candidate); }catch(e){ console.warn(e); }
            } else {
              entry.pendingIce = entry.pendingIce || [];
              entry.pendingIce.push(sig.candidate);
            }
          }
        }
      });
    }

    async function dial(peerId){
      const entry = ensurePeerRecord(peerId);
      try{
        const pc = await createPeerConnection(peerId);
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        roomNode(me.room).get('signals').get(peerId).set({ from: me.id, type:'offer', sdp: offer });
      } finally {
        entry.dialing = false;
      }
    }

    // --- Join / Leave ---
    async function join(){
      if(me.joined){ status(`Already in room: ${me.room}`); return; }
      if(el.relays){
        setCustomRelays(parseRelayInput(el.relays.value), { announce: false });
      }
      const room = (el.room.value || location.hash.slice(1) || 'demo').trim();
      me.room = room; me.name = el.name.value.trim() || `guest-${me.id}`;
      await getUserMediaIfNeeded();
      me.joined = true;
      startSignaling();
      subscribeTestClicks(room);
      // Advertise ourselves
      roomNode(room).get('members').get(me.id).put({ name: me.name, at: Date.now() });
      status(`Joined room: ${room} as ${me.name}`);
      el.join.disabled = true; el.leave.disabled = false;
      el.test.disabled = false;
      updateTestButton();
      history.replaceState(null, '', `#${encodeURIComponent(room)}`);
    }

    async function leave(){
      me.joined = false;
      // Close PCs
      for(const [id, p] of [...peers]){
        if(p.pc) try{ p.pc.close(); }catch{}
        if(id!=='me') removeVideoTile(id);
        peers.delete(id);
      }
      // Stop screen
      if(screenStream){ screenStream.getTracks().forEach(t=>t.stop()); screenStream=null; }
      // Remove from room
      if(me.room){
        roomNode(me.room).get('members').get(me.id).put(null);
        roomNode(me.room).get('testClicks').get(me.id).put(null);
      }
      me.room = null;
      el.join.disabled = false; el.leave.disabled = true;
      el.test.disabled = true;
      if(testWatcher && typeof testWatcher.off === 'function'){ testWatcher.off(); }
      testWatcher = null;
      if(testInitTimer){ clearTimeout(testInitTimer); testInitTimer = null; }
      testClicks.clear();
      setTestState(0, null, null);
      status('Left room.');
    }

    // --- Controls ---
    el.join.onclick = join;
    el.leave.onclick = leave;

    el.cam.onclick = ()=>{
      if(!localStream) return;
      const v = localStream.getVideoTracks()[0]; if(!v) return;
      v.enabled = !v.enabled; el.cam.setAttribute('aria-pressed', String(!v.enabled));
    };
    el.mic.onclick = ()=>{
      if(!localStream) return;
      const a = localStream.getAudioTracks()[0]; if(!a) return;
      a.enabled = !a.enabled; el.mic.setAttribute('aria-pressed', String(!a.enabled));
    };
    el.screen.onclick = async ()=>{
      try{
        if(!screenStream){
          screenStream = await navigator.mediaDevices.getDisplayMedia({video:true,audio:true});
          // Show our own screen as a tile
          const id = 'screen';
          const tile = addVideoTile(id, 'My Screen');
          tile.v.srcObject = screenStream;
          peers.set(id, { stream: screenStream, videos: tile });
          // Add to all PCs
          for(const [,p] of peers){ if(p.pc){ screenStream.getTracks().forEach(t=>p.pc.addTrack(t, screenStream)); } }
          screenStream.getVideoTracks()[0].addEventListener('ended', ()=>{ // cleanup on stop
            removeVideoTile('screen'); peers.delete('screen');
            for(const [,p] of peers){ if(p.pc){ p.pc.getSenders().forEach(s=>{ if(s.track && s.track.kind==='video' && s.track.label.includes('Screen')) s.replaceTrack(null); }); } }
            screenStream=null; status('Screen share stopped.');
          });
        } else {
          screenStream.getTracks().forEach(t=>t.stop()); screenStream=null; removeVideoTile('screen');
      }
    }catch(e){ console.error(e); status('Screen share blocked.'); }
    };

    el.test.onclick = ()=>{
      if(el.test.disabled || !me.joined || !me.room) return;
      const current = testClicks.get(me.id);
      const nextCount = (current?.count || 0) + 1;
      const payload = {
        by: me.id,
        name: me.name,
        count: nextCount,
        at: Date.now()
      };
      testClicks.set(me.id, payload);
      const prevTotal = testState.count;
      recomputeTestState();
      const label = testState.count > prevTotal ? `#${testState.count}` : '';
      status(`Logged test click ${label}`.trim());
      roomNode(me.room).get('testClicks').get(me.id).put(payload);
    };

    // --- Recording (client-side) ---
    function buildMixer(){
      mixerCanvas = document.createElement('canvas');
      mixerCanvas.width = 1920; mixerCanvas.height = 1080;
      mixerCtx = mixerCanvas.getContext('2d');

      // Audio mix
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      mixDest = audioCtx.createMediaStreamDestination();

      // For each available MediaStream with audio, connect to mix
      function connectAudioFrom(stream){
        try {
          const src = audioCtx.createMediaStreamSource(stream);
          const gain = audioCtx.createGain(); gain.gain.value = 1.0; // simple unity gain
          src.connect(gain).connect(mixDest);
        } catch(err){ /* streams without audio will throw */ }
      }

      // Connect current streams
      for(const [id,p] of peers){ if(p?.stream) connectAudioFrom(p.stream); }

      // Observe future streams
      const observer = new MutationObserver(()=>{
        // reconnect on layout changes (naive approach)
      });
      observer.observe(el.videos,{childList:true});

      const draw = ()=>{
        const tiles = [...el.videos.querySelectorAll('video')];
        const n = Math.max(1, tiles.length);
        mixerCtx.fillStyle = '#000'; mixerCtx.fillRect(0,0,mixerCanvas.width,mixerCanvas.height);
        const cols = Math.ceil(Math.sqrt(n));
        const rows = Math.ceil(n/cols);
        const w = mixerCanvas.width / cols, h = mixerCanvas.height / rows;
        tiles.forEach((vid,i)=>{
          const x = (i%cols)*w, y = Math.floor(i/cols)*h;
          try { mixerCtx.drawImage(vid, x, y, w, h); } catch{}
        });
        mixRAF = requestAnimationFrame(draw);
      };
      draw();

      const videoStream = mixerCanvas.captureStream(30);
      const mixed = new MediaStream([
        ...videoStream.getVideoTracks(),
        ...mixDest.stream.getAudioTracks()
      ]);
      return mixed;
    }

    let lastBlob=null;
    el.recStart.onclick = ()=>{
      const stream = buildMixer();
      chunks = [];
      const opts = { mimeType: 'video/webm;codecs=vp9,opus' };
      try{ mediaRecorder = new MediaRecorder(stream, opts); }
      catch(e){ mediaRecorder = new MediaRecorder(stream); }
      mediaRecorder.ondataavailable = (e)=>{ if(e.data.size) chunks.push(e.data); };
      mediaRecorder.onstop = ()=>{
        cancelAnimationFrame(mixRAF);
        lastBlob = new Blob(chunks, {type:'video/webm'});
        el.dl.disabled = false; status(`Recording ready: ${(lastBlob.size/1e6).toFixed(1)} MB`);
      };
      mediaRecorder.start(1000);
      el.recStart.disabled = true; el.recStop.disabled = false; status('Recording…');
    };
    el.recStop.onclick = ()=>{ if(mediaRecorder && mediaRecorder.state!=='inactive') mediaRecorder.stop(); el.recStop.disabled = true; el.recStart.disabled = false; };
    el.dl.onclick = ()=>{
      if(!lastBlob) return; const url = URL.createObjectURL(lastBlob);
      const a = document.createElement('a'); a.href=url; a.download=`3dvr-meet-${Date.now()}.webm`; a.click();
      setTimeout(()=>URL.revokeObjectURL(url), 30000);
    }

    updateTestButton();

    // Auto-fill room from hash
    window.addEventListener('DOMContentLoaded',()=>{
      const r = location.hash.slice(1); if(r) el.room.value = decodeURIComponent(r);
    });
  </script>
</body>
</html>
